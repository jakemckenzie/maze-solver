# Maze Solver in Python

This project is a maze generator and solver implemented in Python for the [Maze Solver course on Boot.dev](https://www.boot.dev/courses/build-maze-solver-python). It generates a maze in a different way than [I did here (randomized DFS)](https://github.com/jakemckenzie/ShortestTradeRoute) or it [might be this one](https://github.com/jakemckenzie/traversing-on-the-cheap) which is apparently [still on twitter](https://x.com/granderojo/status/1001069704486703104). This is a shorter refresher for graphs as I haven't done them in a while and was mostly just fiddling with fiddling with the gui. Coming from web I've read a lot about mvc at this point, thanks DHH. It ensures when you're writing in a sloppy (<3) language like python you can keep the the application logic concerns separated. If I were to approach this problem again [I think I'd use maximum flow](https://youtu.be/dorq_YA6plQ?si=wh9nXvrhr8zGOoxj&t=858), since I've never actually solve this problem that way.

[Roughgarden has a series of books](https://timroughgarden.org/books.html) on algorithms that's a good primer to [TCRC](https://archive.org/details/introduction-to-algorithms-third-edition-2009).

## DFS (recursive)
![DSF](https://github.com/jakemckenzie/maze-solver/blob/main/rand_dfs.gif?raw=true)

# Dijkstra with Heap Queue

![Dijkstra with Heap Queue](https://github.com/jakemckenzie/maze-solver/blob/main/dijkstra_with_heap_queue.gif?raw=true)

# Min-Cut with Ford-Fulkerson (BFS)

![Min-Cut with Ford-Fulkerson (BFS)](https://github.com/jakemckenzie/maze-solver/blob/main/min_cut2.gif?raw=true)

## Features

- **Maze Generation**: no loops, just pure recursion, had to increase the recursion limit because lol python
- **Maze Solving**: uses dfs
- **Animation**: animate() in model.py doesn't need to be in view because it complies with ["immediate mode M/V/C"](https://johno.se/book/immvc.html), I included init to comply with java classes rules and OO
- **MVC Architecture**: Casey Muratori explains this fairly good job of [explaining immediate mode M/V/C here](https://youtu.be/Z1qyvQsjK5Y?si=BCjF3VZ_dotFz9LB).

## Update 1

- **Max Flow aka Min Cut**: I'm still reading about about I would accomplish this given my current data structure. NetworkX min_cost_flow() requires a capacity and weight, I don't know if it's worth translating the data structure but we'll see.
- **Thorup's**: hierachical bucketing + tree components? it appears to exploit properties of undirected graphs with (varying?) integer weights so it doesn't make sense to use here. it also requires a lot of preprocessing to get the data structure right. here is a [good presentation on thorup](https://github.com/npruehs/thorup), I was unaware of the sorting bottle neck for dijkstra's algorithm. the most efficient algorithms tend to require data structures that are a pain in the ass to implement, probably best to stick to calling a library
- **Dijkstra's with Min-Heap Queue**: I ended up going with Dijkstra's algorithm, it required no modifications to gui and once the algorithm was written it just worked. this implementation, and I think the algorithm in general, reduces down to bfs + priority queue. It's interesting when I was taking algorithms over the summer with (years ago at this point) [professor nascimento](https://www.anderson-nascimento.org/), he gave us [an assignment](https://github.com/jakemckenzie/traversing-on-the-cheap/blob/master/main.java) that was meant to be solved with dynamic programming. I the over eager student exclaimed "I bet I can solve with Dijkstra's algorithm in better than O(n^2)!". He was skeptical but it turned [most dynamic programming problems](https://youtu.be/NzgFUwOaoIw?t=15m20s), and [many problems in software](https://courses.csail.mit.edu/6.854/20/sample-projects/A/connection%20_between_SSSP.pdf), reduce to similar sorts of problems. The entire difficulty of that project and this one is representing the data structure somehow, the algorithms are quite elegant.
- **Thoughts**: I've been doing a lot of functional programming lately (F#, might post a repo, Ocaml and Elixir before that) and years ago I tried to learn Haskell after being excited about streams in Java 8. related to the prior paragraph one of the major pitfalls of functional programming is having to manage I/O and maintain the software you write with it. Abstracting out your data completely can write really elegant code for a time but I think functional programming will have a hard time to take off over object-oriented or imperative programming because it's data agnostic and the world is not data agnostic. Thorup's and Min-Cut(Max Flow) require a lot of wrangling of data structures to get to work properly and the [maintainability of that software is questionable](https://www.youtube.com/watch?v=SPwnfSmyAGI). We'd like to just write it once and forget it. I don't think that will ever be a reality so while you can reduce most dynamic programming problems to graph problems, unless we get some way to do it reliably, it's probably not worth bothering.
## Update 2
- **Max Flow aka Min Cut**: for a SSSP this method is suboptimal but this course is in backend development and I've never implemented this algorithm myself, I know it has many applications in backend development. there appears to be a [fundamental relationship between the min-cut of a graph and its shortest path](https://math.stackexchange.com/questions/7184/number-of-cut-sets-and-the-length-of-the-shortest-path), I knew this from my readings but this was an attempt to implement it myself. the shortest path is one of the results of computing the maximum flow as I demonstrate here but it doesn't mean that you're computing it efficiently, efficiency wasn't the point of this exercise.  each cut set must include at least one edge from every path, including the shortest, and edge disjointness limits the number to the path length. if I was wrong here and you're still reading, this was a learning exercise, I wouldn't mind receiving [feedback](https://x.com/granderojo).
- **Notes**: I've been planning out the large capstone project for this course, this was the last [python course for the entire website](https://www.boot.dev/courses/build-capstone-project). I still plan on adding to the to the static site generator project (making the markdown to html conversion more robust which is turning out to be a [lot harder problem than they let on from the start](https://pw374.github.io/posts/2013-09-05-22-31-26-about-omd.html), tl;dr you're making a compiler for a language which is semantically ambigous). the second half of bootdev coursework is entirely in go, a language I have familarity in and like a lot. what I'm running into as an issue is what backend language to choose. Right now I'm heavily leaning towards go, my issue is that I desperately want a job doing backend. Most of the jobs in my area are primarily Csharp (mostly) and some Java. I don't really have a preference over either of those languages at this point. I'm leaning towards doing this project in all three languages or doing a slightly different problem with a federated backend in all three. the first problem to mostly to understand the problem I'm aiming at solving and both problems show that I'm language agnostic as an engineer. At the end of the day I care less about bikeshedding multiple programming languages, I want to make something that doesn't suck within the constraints of the problems I'm solving. I don't know what language will be the best for this problem at my current skill level and this seems like the best way to make something that doesn't suck while showing my skills to employers. I've talked to a lot of enterprise shops and they are skeptical about language agnosticism. I'd like to show that I can build something that doesn't suck in the language of their choice and others. Fin.
- **Future Work**: I mage change this from a SSSP to a larger maze with MSMP maze to visualize the flow, currently I'm not using that to visualize the min-cut algorithm because there is no point.  general graphs with varying sources and sinks, ford-fulkerson would continue finding augmenting paths until the maximum flow is reached, and the minimum cut would be computed from the final residual graph